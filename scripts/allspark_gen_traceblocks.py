import json
import struct
import sys
from enum import Enum, auto
from dataclasses import dataclass
from pathlib import Path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter

class TraceTargetType(Enum):
    BR = 0
    CALL_INDIRECT = 1
    EOT = 2

class LayoutInstType(Enum):
    BRANCH = 0
    CALL = 1
    CALL_INDIRECT = 2
    TARGET = 3
    RETURN = 4
    GENERIC = 5

@dataclass
class CallFrame:
    func: str
    block: str
    idx: int

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def print_transition(message=""):
    print(f" | \n | {message} \n V ")


def parse_args():
    parser = ArgumentParser(prog='allspark_gen_traceblocks.py', 
        description='Generate traceblocks given static instruction layout and dynamic trace from Allspark',
        formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('-t', '--trace', type=Path, required=True, 
        help='Allspark trace (.aspk)')
    parser.add_argument('-l', '--layout', type=Path, required=True,
        help='Allspark layout (.json) generated by allspark_trace_blocks inspection')
    parser.add_argument('-m', '--main', type=str, default='_start',
        help='Export name of main function that is invoked')
    parser.add_argument('-d', '--debug', action='store_true', help='Print extra data to debug files')
    parser.add_argument('-r', '--dry', action='store_true', help='Compute only stats, not trace')
    parser.add_argument('-v', '--verbose', action='store_true',
        help='Print verbose output')
    return parser.parse_args()


def process_aspk_trace(tracefile, layout, debug=False):
    '''
        Process tracefiles into readable formats
        Returns the dictionary of ctrl-flow information
    '''
    # Each 8-byte entry is packed as:
    # <3 byte target pc> <3 byte source pc> <2 byte function index> 
    timestamp_struct = struct.Struct('<Q')
    entry_struct = struct.Struct('<Q')

    field_splits = [3, 3, 2]
    field_split_idxs = [
        sum(field_splits[:i]) for i in range(len([0] + field_splits))
    ]

    with open(tracefile, 'rb') as f:
        data = f.read()

    cf_types = ['branch', 'call_indirect']
    cf_stats = { k: {} for k in cf_types }
    cf_flow = []

    timestamp, = timestamp_struct.unpack(data[:timestamp_struct.size])

    for entry, in entry_struct.iter_unpack(data[timestamp_struct.size:]):
        eb = entry.to_bytes(8, byteorder='little')
        target, source_pc, func_idx = [
            str(int.from_bytes(
                eb[field_split_idxs[i]:field_split_idxs[i+1]], byteorder='little'
            )) for i in range(len(field_splits))
        ]

        def record_stat(cfd):
            '''
                Record the statistics for a control flow type
            '''
            if func_idx not in cfd:
                cfd[func_idx] = {}
            if source_pc not in cfd[func_idx]:
                cfd[func_idx][source_pc] = {}
            if target not in cfd[func_idx][source_pc]:
                cfd[func_idx][source_pc][target] = 0
            cfd[func_idx][source_pc][target] += 1

        # Determine if entry is a call_indirect
        if func_idx in layout and source_pc in layout[func_idx]['call_indirect_sites']:
            cf_flow.append((func_idx, source_pc, target, TraceTargetType.CALL_INDIRECT.value))
            record_stat(cf_stats['call_indirect'])
        else:
            cf_flow.append((func_idx, source_pc, target, TraceTargetType.BR.value))
            record_stat(cf_stats['branch'])

    # Pad cf_flow with last value for runthrough
    cf_flow.append((cf_flow[-1][0], -1, -1, TraceTargetType.EOT.value))

    def compute_stats(cfd):
        '''
            Compute the static and dynamic stats for a ctrlflow type
        '''
        num_sites = 0
        target_types = {k: 0 for k in ["uncond", "two-way cond", "multi-way cond"]}
        for src_pc_table in cfd.values():
            num_sites += len(src_pc_table)
            for target_pc_table in src_pc_table.values():
                num_targets = len(target_pc_table.values())
                if num_targets == 1:
                    target_types["uncond"] += 1
                elif num_targets == 2:
                    target_types["two-way cond"] += 1
                elif num_targets > 2:
                    target_types["multi-way cond"] += 1
        return {
            'sites': num_sites,
            'site_types': target_types
        }

    cf_info = {k: compute_stats(cf_stats[k]) for k in cf_types}

    eprint(f"=== TRACE INFO ===")
    # -1 since we omit padding
    eprint(f"Total dynamic entries: {len(cf_flow) - 1}")
    eprint(f"Timestamp: {timestamp // 1_000_000} s | {(timestamp % 1_000_000) // 1_000} ms")
    eprint(f"--- Stats ---")
    eprint(json.dumps(cf_info, indent=2))
    eprint(f"==================")

    if debug:
        with open('trace_stats.json', 'w') as f:
            json.dump(cf_stats, f, indent=4)
        with open('trace_flow.json', 'w') as f:
            json.dump(cf_flow, f, indent=4)
        with open('layout.json', 'w') as f:
            json.dump(layout, f, indent=4)

    return cf_flow, timestamp


def print_trace_starting_from_func(trace_iter, trace_entry_enum, layout, funcidx):
    '''
        Display the instruction trace for a function starting func
    '''
    start_first_block = layout[str(funcidx)]['first_block']
    call_stack = [CallFrame(func=str(funcidx), block=str(start_first_block), idx=0)]

    func_switch = True
    
    while call_stack:
        cur_frame = call_stack[-1]
        # Local State for the basic block
        cur_block = cur_frame.block
        cur_block_insts = layout[cur_frame.func]['br_blocks'][cur_frame.block]
        cur_func_name = layout[cur_frame.func]['name']
        begin_inst_idx = cur_frame.idx
        # Special results after running through a basic block
        func_switch = False
        return_found = False

        print("Frame (func=[{} | {}{}], block={}, idx={})".format(
            cur_frame.func, 
            cur_func_name, 
            " | IMPORT" if int(cur_frame.func) < layout['import_func_count'] else "",
            cur_frame.block, cur_frame.idx
        ))
        
        for i, inst in enumerate(cur_block_insts[begin_inst_idx:]):
            pc = inst['pc']
            # Trace-related information
            trace_counter, trace_entry = trace_entry_enum
            trace_func_idx, trace_src_pc, trace_target = (str(x) for x in trace_entry[:-1])
            trace_target_type = trace_entry[-1]

            print(f"{int(pc):06x} {inst['inst']}")
            if inst['type'] == LayoutInstType.BRANCH.value:
                # Move to next block based on trace
                assert (begin_inst_idx + i) == len(cur_block_insts) - 1, \
                    f"Branch instruction should be last in block {cur_frame.idx + i} {len(cur_block_insts)-1}"
                assert trace_func_idx == cur_frame.func, \
                    f"Function index mismatch {trace_func_idx} {cur_frame.func}"
                assert trace_src_pc == pc, f"Source PC mismatch {trace_src_pc}, {pc}"
                assert trace_target_type == TraceTargetType.BR.value, f"Target type mismatch {trace_target_type} {TraceTargetType.BR.value}"
                # Consume trace entry
                # Get the index from target sites, get the block from next entry
                target_site = layout[cur_frame.func]['target_sites'][trace_target]
                cur_frame.idx = target_site['idx']
                cur_frame.block = target_site['block']
                trace_entry_enum = next(trace_iter)
                print_transition(f"Branch | Trace[{trace_counter}]")
                break
            elif inst['type'] == LayoutInstType.CALL.value:
                # Add frame to call stack
                target_func = layout[cur_frame.func]['call_direct_sites'][pc]
                call_stack.append(CallFrame(func=target_func, block=layout[target_func]['first_block'], idx=0))
                print_transition("Direct Call")
                func_switch = True
            elif inst['type'] == LayoutInstType.CALL_INDIRECT.value:
                # Add frame to call stack (but based on trace)
                assert trace_target_type == TraceTargetType.CALL_INDIRECT.value, \
                    f"Target type mismatch {trace_target_type} {TraceTargetType.CALL_INDIRECT.value}"
                target_func = trace_target
                # Consume trace entry
                trace_entry_enum = next(trace_iter)
                call_stack.append(CallFrame(func=target_func, block=layout[target_func]['first_block'], idx=0))
                print_transition(f"Indirect Call | Trace[{trace_counter}]")
                func_switch = True
            elif inst['type'] == LayoutInstType.RETURN.value:
                return_found = True
                func_switch = True
                break

            cur_frame.idx += 1
            if func_switch:
                break
        
        # End of function (or return) blocks pop the call stack
        if return_found or (cur_block == "-1" and cur_frame.idx == len(cur_block_insts)):
            call_stack.pop()
            func_switch = True
            print_transition("Func Return")
    
    print("----")
    return trace_iter, trace_entry_enum


def print_blocks_from_trace(trace_flow, layout, main_exportname):
    '''
        Using layout to generate instructions from trace_flow
    '''
    main_funcidx = layout['func_exports'][main_exportname]
    start_funcidx = layout.get('start_funcidx')

    # Determine whether start and main functions need to be printed separately
    main_first_block = layout[str(main_funcidx)]['first_block']

    trace_iter = enumerate(trace_flow)
    trace_entry_enum = next(trace_iter)

    if start_funcidx:
        trace_iter, trace_entry_enum = print_trace_starting_from_func(trace_iter, trace_entry_enum, layout, start_funcidx)

    print("\n")
    trace_iter, trace_entry_enum = print_trace_starting_from_func(trace_iter, trace_entry_enum, layout, main_funcidx)

def main():
    args = parse_args()
    with open(args.layout, 'r') as f:
        layout = json.load(f)

    trace_flow, timestamp = process_aspk_trace(args.trace, layout, args.debug)
    if not args.dry:
        print(f"Assuming invocation of {args.main} as main function")
        print_blocks_from_trace(trace_flow, layout, args.main)
    
if __name__ == '__main__':
    main()