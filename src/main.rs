//! Binary crate for running a collect an AllSpark
//! `plc-trace` instrumented program from [`wasm_instrument`]
//!
//! [`wasm_instrument`]: https://github.com/arjunr2/wasm-instrument.git
//!
//! Inputs to this program must accept post-instrumented binaries; this crate
//! **does not** provide instrumentation facilities
use clap::Parser;
use log::{debug, info};
use once_cell::sync::Lazy;

use libc::c_void;
use std::error::Error;
use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::mem;
use std::path::{Path, PathBuf};
use std::ptr;
use uuid::Uuid;

use serde::{Deserialize, Serialize};
use serde_pickle::de as picklede;
use serde_pickle::ser as pickleser;
use tempfile::env;

use wamr_rust_sdk::{instance::Instance, module::Module, runtime::Runtime};
use wamr_rust_sdk::{
    log_level_t, wasm_exec_env_t, wasm_runtime_addr_app_to_native, wasm_runtime_get_module_inst,
    LOG_LEVEL_WARNING,
};

/// A Lazy-initialized temporary disk-backed filepath
static TMP_FILEPATH: Lazy<PathBuf> = Lazy::new(|| {
    let mut temppath = env::temp_dir();
    temppath.push(Uuid::new_v4().to_string());
    info!("Intermediate tracefile: {:?}", temppath);
    temppath
});

static mut TMPFILE_WR: Lazy<BufWriter<File>> =
    Lazy::new(|| BufWriter::new(File::create(&*TMP_FILEPATH).unwrap()));
/// Number of operations logged into temporary file
static mut NUM_OPS: u64 = 0;

/// Command-Line Arguments
#[derive(Parser, Debug)]
#[command(version, about, long_about=None)]
struct CLI {
    /// Log-level within the Wasm engine
    #[arg(short, long, default_value_t = LOG_LEVEL_WARNING)]
    verbose: log_level_t,

    /// Output trace file
    #[arg(short, long, default_value_t = String::from("trace.aspk"))]
    outfile: String,

    /// Input Command (Wasm program path + Argv)
    #[arg(num_args = 1..)]
    input_command: Vec<String>,
}

impl CLI {
    /// Print the CLI configuration
    fn print(&self) {
        info!("Input Command: {:?}", self.input_command);
        info!("Outfile: {}", self.outfile);
        info!("Log Level: {:?}", self.verbose);
    }
}

/// Packed u64 for trace data
#[derive(Serialize, Deserialize, Debug)]
#[repr(packed)]
struct OpDistEntry {
    op: u32,
    count: u32,
}
/// Single entry in trace, generated by [`wasm_prog_tracedump`]
#[derive(Serialize, Deserialize, Debug)]
struct ProgTraceEntry {
    scope_id: u32,
    opdist: Vec<OpDistEntry>,
}

/// Finalized trace data
#[derive(Serialize, Deserialize, Debug)]
struct ProgTraceData {
    data: Vec<ProgTraceEntry>,
}

// impl ProgTraceEntry {
//    pub fn ser_to_writer(&self, writer: &mut dyn Write) -> Result<(), Box<dyn
// Error>> {        writer.write(self.scope_id.to_le_bytes().as_ref())?;
//        writer.write((self.opdist.len() as u32).to_le_bytes().as_ref())?;
//        for entry in &self.opdist {
//            writer.write(entry.op.to_le_bytes().as_ref())?;
//            writer.write(entry.count.to_le_bytes().as_ref())?;
//        }
//        Ok(())
//    }
//}
// fn read_ser(reader: &mut dyn Read) -> ProgTraceData {
//    let p = ProgTraceData {
//        data: Vec::new(),
//    };
//
//}

/// Wasm function to dump trace
///
/// Scope ID is used to identify the scope which is being traced
/// opcount_buf_addr is a pointer to buffer containing opcode distribution
/// buf_size is the size of the buffer
/// Get the timestamp for this block too
fn wasm_prog_tracedump(
    exec_env: wasm_exec_env_t,
    scope_id: u32,
    opcount_buf_addr: u32,
    buf_size: u32,
) {
    // info!("Tracedump: Scope ID: {}", scope_id);
    let mut entry = ProgTraceEntry {
        scope_id,
        opdist: Vec::with_capacity(buf_size as usize),
    };
    unsafe {
        let module = wasm_runtime_get_module_inst(exec_env);
        let buf_addr: *mut c_void =
            wasm_runtime_addr_app_to_native(module, opcount_buf_addr as u64);
        ptr::copy_nonoverlapping(
            buf_addr as *const u8,
            entry.opdist.as_mut_ptr() as *mut u8,
            buf_size as usize,
        );
        entry
            .opdist
            .set_len(buf_size as usize / mem::size_of::<OpDistEntry>());
    }
    unsafe {
        pickleser::to_writer(&mut *TMPFILE_WR, &entry, pickleser::SerOptions::new()).unwrap();
        NUM_OPS += 1;
    }
    debug!(
        "Tracedump: Scope ID: {}; Vec: {:?}",
        entry.scope_id, entry.opdist
    );
}

/// Generate finalized trace data
fn generate_trace_data(outfile: &String) -> Result<(), Box<dyn Error>> {
    let mut tracefile = File::create(outfile)?;
    let mut ops_file = BufReader::new(File::open(&*TMP_FILEPATH)?);
    let mut tracedata = ProgTraceData {
        data: Vec::with_capacity(unsafe { NUM_OPS } as usize),
    };
    for i in 0..unsafe { NUM_OPS } {
        info!("Reading trace entry: {}", i);
        let entry: ProgTraceEntry =
            picklede::from_reader(&mut ops_file, picklede::DeOptions::new())?;
        info!("Read trace entry: {:?}", entry);
        tracedata.data.push(entry);
    }
    pickleser::to_writer(&mut tracefile, &tracedata, pickleser::SerOptions::new())?;
    Ok(())
}

/// Entrypoint for trace
fn main() -> Result<(), Box<dyn Error>> {
    env_logger::builder().format_timestamp_millis().init();
    let cli = CLI::parse();
    cli.print();

    // Read arguments
    let infile = cli.input_command[0].as_str();
    let infile_path = Path::new(infile);

    let runtime = Runtime::builder()
        .use_system_allocator()
        .set_host_function_module_name("plc-trace")
        .register_host_function("prog_tracedump", wasm_prog_tracedump as *mut c_void)
        .set_max_thread_num(100)
        .build()?;
    runtime.set_log_level(cli.verbose);
    let module = Module::from_file(&runtime, infile_path)?;
    let instance = Instance::new(&runtime, &module, 1024 * 256)?;

    let _ = instance.execute_main(&cli.input_command)?;
    info!("Wasm module execution completed");

    unsafe {
        TMPFILE_WR.flush()?;
    }
    generate_trace_data(&cli.outfile)?;

    Ok(())
}
